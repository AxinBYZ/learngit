<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>js整理</title>
	<style>
		p.timer{
			width: 400px;
			background:#ddd;
			height:40px;
			line-height:40px;
			font-size:20px;
			text-align: center;
		}
	</style>
</head>
<body>
	<p class="timer">javascript</p>
</body>
<script>

/***********************js整理******************************/

/*************字符串**************/
/*
	1.多行字符串
		由于多行字符串用\n写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用` ... `表示：
		var str=`多行
		字符串
		测试`;
		alert(str);
	2.模版字符串
		要把多个字符串连接起来，可以用+号连接;如果有很多变量需要连接，用+号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量
		var name="小明";
		var age=20;
		var message=`你好，${name},你今年${age}岁了！`;
		alert(message);
	3.字符串常见操作
		1>*字符串是不可变得，如果对字符串的某个索引复制不会有任何错误，但是也没有效果
		var s='text';
		s[0]="Y";
		alert(s);//任然为text;
		
		2> indexOf() 会搜索指定字符串出现的位置
		var str = 'hello world!';
		var num = str.indexOf('world');//返回6
		var num1 = str.indexOf('World');//返回-1

		3> substring() 提取指定索引区间的子串,并返回子串
		var str = 'hello world!';
		var str1=str.substring(1,7);//返回ello w(不包括7)
		var str2 = str.substring(2);//从2开始到结尾

		4>match 匹配对应的字符串，匹配到返回该字符串，否则返回null
		var str="Hello world!2 plus 1 equal 3"
		document.write(str.match("world") + "<br />")//world
		document.write(str.match("World") + "<br />")//null
		document.write(str.match("worlld") + "<br />")//null
		document.write(str.match("world!")+"<br />")//world!
		document.write(str.match(/\d+/g));//2,1,3(用逗号隔开)
		
		5>replace 字符串替换,返回新的字符串  stringObject.replace(regexp/substr,replacement)
		var str='hello world!';
		var str1 = str.replace('world','xiaowang');
		var str2 = str.replace(/world/,'xiaoming');
		alert(str1);//hello xiaowang!
		
		6>search 检索指定字符串的位置
		var str="hello world!";
		var num = str.search('world');//6

		7>slice 提取指定索引区间的子串 同substring()  只是接受负数是有差别 slice()会把负数解析成从后往前数 substring()会把负数解析称0 
		
		8>substr 提取子串，第一个参数是开始位置，第二个参数是长度
		var str = 'hello world';
		var str1 = str.substr(1,4);
		alert(str1);//ello
		
		9>sub() sup() 下标 上标

		10>toUpperCase() toLowerCase() 大写小写

		11>split()把一个字符串分解成一个字符串数组
		var str = 'xiaoming xiaohong xiaoliang';
		var arr = str.split(' ');
*/

/*************数组**************/
/*
	1.数组长度
		通过索引赋值时，如果索引大于数组长度会引起数组长度的变化
		var arr=[1,2,3]
		arr[4]=5;
		alert(arr[3]);//undefined
		alert(arr[4]);//5
	2.indexOf() 返回指定元素的位置
		var arr=[1,2,3];
		var num = arr.indexOf(3);
		alert(num)//2
	3.slice() 截取arr的部分元素，返回新的arr
		var arr =[1,2,3,4,5];
		var arr1 = arr.slice(1,3);//2,3
		var arr2 = arr.slice(2);//从索引2开始3，4，5
		var arr3 = arr.slice();//如果不给参数，它就会从头到尾截取所有元素，利用这一点，我们就可以很容易复制一个arr;
		alert(arr3==arr)//false
	4.push() 和pop() push()向数组的最后添加若干元素，返回新书组的长度，pop()删除最后一个元素，返回被删除元素
		var arr = [1, 2];
		arr.push('A', 'B'); // 返回Array新的长度: 4
		arr; // [1, 2, 'A', 'B']
		arr.pop(); // pop()返回'B'
		arr; // [1, 2, 'A']
		arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次
		arr; // []
		arr.pop(); // 空数组继续pop不会报错，而是返回undefined
		arr; // []
	5.unshift和shift
		如果要往arr头部添加若干元素，使用unshift()方法，shift()方法则把arr的第一个元素删除掉	
		var arr = [1, 2];
		arr.unshift('A', 'B'); // 返回Array新的长度: 4
		arr; // ['A', 'B', 1, 2]
		arr.shift(); // 'A'
		arr; // ['B', 1, 2]
		arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次
		arr; // []
		arr.shift(); // 空数组继续shift不会报错，而是返回undefined
		arr; // []
	6.sort() 可以对当前数组进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序：
		var arr = ['B', 'C', 'A'];
		arr.sort();
		arr; // ['A', 'B', 'C']
	7.reverse() 反转整个数组
		var arr=['a','b','c','d']	
		var arr1=arr.reverse();
		alert(arr1);
	8.splice() 方法是修改arr的‘王能方法’，他可以从指定的索引开始删除若干元素，然后从该位置添加若干元素
		var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];
		// 从索引2开始删除3个元素,然后再添加两个元素:
		arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']
		arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
		// 只删除,不添加:
		arr.splice(2, 2); // ['Google', 'Facebook']
		arr; // ['Microsoft', 'Apple', 'Oracle']
		// 只添加,不删除:
		arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素
		arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
	9.concat() 把当前的arr和另一个arr连接起来，并返回新的arr。
		var arr = ['A', 'B', 'C'];
		var added = arr.concat([1, 2, 3]);
		added; // ['A', 'B', 'C', 1, 2, 3]
		arr; // ['A', 'B', 'C']
	10.join() 方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串
		var arr = ['a','b','c','d'];
		arr.join('-');//'a-b-c-d'; (如果arr的元素不是字符串，将自动转换为字符串之后再连接)
	11.多维数组
*/
/*************Math对象的方法****/
/*
	1.round() 四舍五入
		alert(Math.round(4.6))//5
	2.random() 0~1之间的一个随机数
		alert(Math.random());
	3.ceil() floor() 向上取整和向下取整
		alert(Math.ceil(Math.random()*3));
	4.pow(x,y) x的y次幂
		alert(Math.pow(2,3));//8
	5.max() min() 
		alert(Math.max(2,8))//8
*/
/*************Date对象的方法****/
/*
	1.定义日期
		var newDate = new Date();
		alert(newDate);//Date 对象自动使用当前的日期和时间作为其初始值。
	2.操作日期
		getDate() 返回一个月中的某一天(1-31)
		getDay() 返回一周中的某一天(0-6)
		getMonth() 返回月份(0-11);返回值是 0（一月） 到 11（十二月） 之间的一个整数
		getFullYear() 以四位数字返回年份
		getHours() 返回小时（0-23）
		getMinutes() 返回分钟(0-59)
		getSeconds() 返回秒数(0-59)
		getTime() 返回1970年1月1日至今的毫秒数
		setDate() 返回Date对象中的某一天(1-31)
		setMonth() 设置月份（0-11）
		setFullYear()
		setHours()
		setMimutes()
		setSeconds()
		setTime()
	3.实现一个倒计时效果
		function timer(){
			var timer1 = null;
			timer1 = setInterval(function(){
				var ts=(new Date(2016,7,23,13,55,0))-(new Date());//目标时间和现在相差的毫秒数；
				var ms=ts%1000,//毫秒数
					s=(ts-ms)/1000%60,//秒数
					m=(ts-ms-s*1000)/1000/60%60,//分钟
					h=(ts-ms-s*1000-m*60*1000)/1000/60/60%24,//小时
					d=(ts-ms-s*1000-m*60*1000-h*60*60*1000)/24;//天数
				s=checkTime(s);m=checkTime(m);h=checkTime(h);
				document.getElementsByTagName('p')[0].innerHTML=`倒计时${d}天${h}小时${m}分钟${s}秒`;
			},1000)
		}
		function checkTime(num){
			if(num<10){
				num="0"+num;
			}
			return num;
		}
*/
/*************对象**************/
/*
	1.对象的声明,添加和删除属性
		var xiaoming={
			name:'xiaoming',
			age:20
		}
		xiaoming.birth = 1990;
		delete xiaoming.age;
	2.如果对象的属性包含特殊字符，应该用''包起来,访问的时候也无法用.来访问，需要用[]
		var xiaohong={
			name:'xiaohong',
			'middle-school':'No1 middle school'
		}
		xiaohong['middle-school'];
		xiaohong['name']==xiaohong.name
	3.访问一个不存在的属性时，浏览器不报错而是返回undefined;要检测是否拥有一个属性时可以用in操作符;不过如果用in操作符判断一个属性存在，这个属性可能不是本身就有的，而是继承得到的;对于这种情况可以用hasOwnProperty()方法
		var xiaoming={
			name:'xiaoming',
		}
		xiaoming.age;//undefined;
		'name' in xiaoming;//true
		'age' in xiaoming;//false
		'toString' in xiaoming;//true  继承得到的
		xiaoming.hasOwnProperty('name')//true
		xiaoming.hasOwnProperty('toString')//false
	4.JavaScript把null、undefined、0、NaN和空字符串''视为false，其他值一概视为true，
*/
/*************Map和Set**************/
/*
	1.Map Map是一组键值对的结构，具有极快的查找速度。
		var m=new Map([['xiaoming',95],['xiaohong',99],['xiaoliang',85]]);
		m.get('xiaoming')
		m.set('xiaowang',100);
		m.has('xiaoliang');
		m.delete('xiaoliang');
		m.get('xiaoliang')
		初始化一个Map()
		var mm=new Map();
	2.Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。
		var s1 = new Set();//空的Set
		var s2 = new Set([1,2,3]);//含1，2，3
		//通过add(key)方法添加元素，可以重复添加一个元素，但是不会有效果
		s2.add(4)
		s2//1,2,3,4
		s2.add(4)
		s2//1,2,3,4
		//通过delete(key)可以删除元素
		s2.delete(3);
		s2//1,2,4
	3.iterable  遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。具有iterable类型的集合可以通过新的for ... of循环来遍历。for...of循环是ES6引入的新的语法
		var a = ['A', 'B', 'C'];
		var s = new Set(['A', 'B', 'C']);
		var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
		for (var x of a) { // 遍历Array
		    alert(x);
		}
		for (var x of s) { // 遍历Set
		    alert(x);
		}
		for (var x of m) { // 遍历Map
		    alert(x[0] + '=' + x[1]);
		}
		//for...of 和for...in 的区别 for ... in循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性
		//当我们手动给Array对象添加了额外的属性后，for ... in循环将带来意想不到的意外效果：
		var a = ['A', 'B', 'C'];
		a.name = 'Hello';
		for (var x in a) {
		    alert(x); // '0', '1', '2', 'name'
		}
		//for ... in循环将把name包括在内，但Array的length属性却不包括在内。for ... of循环则完全修复了这些问题，它只循环集合本身的元素
		//更好的方法是直接使用iterable内置的forEach方法，它接受一个函数，每次迭代就自动回调该函数，以Array为例：
		var arr = ['a','b','c'];
		a.forEach(function(element, index, array){
			 // element: 指向当前元素的值
    		// index: 指向当前索引
    		// array: 指向Array对象本身
			alert()
		})
		//注意，forEach()方法是ES5.1标准引入的，你需要测试浏览器是否支持。Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身：
		var s = new Set(['A', 'B', 'C']);
		s.forEach(function (element, sameElement, set) {
		    alert(element);
		})
		//Map的回调函数参数依次为value、key和map本身：
		var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
		m.forEach(function (value, key, map) {
		    alert(value);
		});
*/
/***************函数****************/
/*
	1.throw 抛出错误
		function abs(x){
			if(x>10){
				throw '数字大于10了';
			}
			if(x<10){
				alert(x);
			}
		}
	2.arguments 关键字，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但并不是一个Array:
		function foo(x){
			alert(x);
			for(var i=0;i<arguments.length;i++){
				alert(arguments[i]);
			}
		}
		foo(10,20,30);//10 10 20 30
	3.rest参数
		function foo(a, b) {
		    var i, rest = [];
		    if (arguments.length > 2) {
		        for (i = 2; i<arguments.length; i++) {
		            rest.push(arguments[i]);
		        }
		    }
		    console.log('a = ' + a);
		    console.log('b = ' + b);
		    console.log(rest);
		}
		//为了获取除了已定义参数a、b之外的参数，我们不得不用arguments，并且循环要从索引2开始以便排除前两个参数，这种写法很别扭，只是为了获得额外的rest参数，有没有更好的方法？
		function foo(a, b, ...rest) {
		    console.log('a = ' + a);
		    console.log('b = ' + b);
		    console.log(rest);
		}
		//rest参数只能写在最后，前面用...标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments我们就获取了全部参数。如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是undefined）。
	4.变量及作用域
		1>变量提升 javascript的函数定义有个特点，它会先扫描整个函数体的语句，把所有声明的变量‘提升’到函数顶部：
		function fo(){
			var x='hello '+y;
			alert(x);
			var y = 'bob'
		}
		fo();//hello undefinded; 只是提升了变量y的声明，并没有提升变量y的复制
		//由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。最常见的做法是用一个var申明函数内部用到的所有变量：
		function foo(){
			var 
				x = 1,
				y = 2,
				z = x+y;
			if(){
				...
			}
		}
		2>全局作用域 不在任何函数内定义的变量就具有全局作用域，实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性：
		var course = 'Learn JavaScript';
		alert(course);//'Learn JavaScript';
		alert(window.course);//'Learn JavaScript';
		//因此，直接访问全局变量course和访问window.course是完全一样的。由于函数定义有两种方式，以变量方式var foo = function () {}定义的函数实际上也是一个全局变量，因此，顶层函数的定义也被视为一个全局变量，并绑定到window对象:
		function foo(){
			alert('hello')
		}
		foo();//直接调用foo();
		window.foo();//通过window.foo()调用
		window.alert('hehe');
	5.名字空间 全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个变量中，例如：
		var MYAPP = {}//唯一的全局变量
		//其它变量
		MYAPP.name="myapp";
		MYAPP.version = 1.0;
		//其它函数
		MYAPP.foo = function(){
			return 'foo';
		}
	//把自己的代码全部放入唯一的名字空间MYAPP中，会大大减少全局变量冲突的可能。许多著名的js库都是这么干的：jQuery ,YUI,underscore等等。
	6.局部作用域 由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的：
		function foo(){
			for(var i=0;i<100;i++){
				...
			}
			i+=100;//还是可以引用变量i
		}
	//为了解决块级作用域，ES6引入了新的关键字let,用let替代var可以申明一个块级作用域的变量：
		function foo(){
			var sum = 0;
			for(let i=0;i<100;i++){
				sum +=i;
			}
			i +=1;//SyntaxError;
		}
	7.常量 由于var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量表示‘这是一个常量，不要修改它的值’
		var PI=3.14;
	在ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域：
		const PI=3.14;
		PI=3;//某些浏览器不报错，但是无效果。
		PI;//3.14
	8.this this指针只在方法的函数内指向xiaoming，在函数内部定义的函数，this又指向undefined了！（在非strict模式下，它重新指向全局对象window！）
		var xiaoming = {
		    name: '小明',
		    birth: 1990,
		    age: function () {
		        var that = this; // 在方法内部一开始就捕获this
		        function getAgeFromBirth() {
		            var y = new Date().getFullYear();
		            return y - that.birth; // 用that而不是this
		        }
		        return getAgeFromBirth();
		    }
		};
	9.apply 控制this的指向。要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接受两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。
		function getAge(){
			var y=new Date().getFullYear();
			return y-this.birth;
		}
		var xiaoming={
			name:'xiaoming',
			birth:1990,
			age:getAge
		}
		xiaoming.age();//25
		getAge.apply(xiaoming,[]);//25 ,this指向xiaoming 参数是空
	10.call() 和apply()方法类似，唯一的区别是：
		apply把参数打包成array再传入；call()把参数按顺序传入。
		比如调用Math.max(3,5,4),分别用apply()和call()实现如下：
		Math.max.apply(null,[3,5,4]);//5
		Math.max.call(null,3,5,4);//5
		对普通函数调用，我们通产把this绑定为null.
*/


























































































































































</script>
</html>